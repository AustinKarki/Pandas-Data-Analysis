# -*- coding: utf-8 -*-
"""Pandas part 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gAX2hpRKxhO7MK19VjGGhhAfhhS0jIF8
"""

# Data manipulation - Data analysis to take out insite from data, Data management
# Data structure - Series , Dataframes

# Series = 1 dimension labeled array (any datatype can be hold, similar to list same[bracket])
# Dataframes= 2 dimension


from google.colab import drive
drive.mount("/content/drive") # to connect drive to google colab

# pip install pandas
import pandas as pd
data = pd.Series(["nepal",0.5,0.75,1.0])
print(data)
print()

a={"name":["ram","shyam","hari"],
   "age":[22,23,24],
   "score":[98,97,99]}
df=pd.DataFrame(a)
print(df)

df =pd.read_csv("/content/drive/MyDrive/Techaxis/survey_results_public (2).csv")
schema_df=pd.read_csv("/content/drive/MyDrive/Techaxis/survey_results_schema (2).csv")
df

# df.to_csv(new.csv,index=False) = to create csv file
df.shape # to dispaly row and column

df.info()

df.describe()

df["Hobbyist"]

df["Hobbyist"].value_counts()

df["Gender"]

df["Gender"].value_counts()

# indexing and selecting data
# .loc(Local based indexing) = int variable = more filter than iloc
# iloc(Interger based position) = primary integer position based =int

df.loc[0]

df.loc[0,"Hobbyist"]

df.loc[0:2,"Hobbyist"]

df.loc[0:100,"Hobbyist"]

df.loc[0:100,"Hobbyist":"Employment"]

# type of data analysis
schema_df

schema_df=pd.read_csv("/content/drive/MyDrive/Techaxis/survey_results_schema (2).csv", index_col="Column")
schema_df

schema_df.loc["Respondent","QuestionText"]

schema_df.loc["Hobbyist","QuestionText"]

df =pd.read_csv("/content/drive/MyDrive/Techaxis/survey_results_public (2).csv", index_col="Respondent")
df

# reverse
df.sort_index(ascending=False)

df['Country'] == "Nepal"

(df['Country'] == "Nepal").value_counts()

df[df['Country'] == "Nepal"]

filter_nepal=df['Country'] == "Nepal"
a=df[filter_nepal]

schema_df.sort_index(ascending=False)

a = {"aa": ["nepal", "Nepal", "nEpal", "NEPAL"]}
a['aa'].sort()
print(a['aa'])


a = {"aa": ["nepal", "Nepal", "nEpal", "NEPAL"]}
print(sorted(a['aa']))

df.loc[filter_nepal]

df.loc[filter_nepal,"MgrIdiot"]

df.loc[filter_nepal,"MgrIdiot"].value_counts()

import matplotlib.pyplot as plt #py plot
df.loc[filter_nepal,"MgrIdiot"].value_counts().plot()
plt.show()

df.loc[filter_nepal,"MgrIdiot"].value_counts().plot.bar()
plt.show()

df.loc[filter_nepal,"MgrIdiot"].value_counts().plot.pie()
plt.show()
# matplot and pandas =seaborn



filter_idiot=(df["Country"] == "Nepal") & (df["MgrIdiot"] == "Not at all confident")
filter_idiot.value_counts()

df.loc[filter_idiot]

df["ConvertedComp"].value_counts()

df.loc[filter_idiot,"ConvertedComp"].value_counts()

a=df.loc[filter_idiot,"ConvertedComp"].mean()
print(f"{a:.3f}")

df.loc[filter_idiot,"ConvertedComp"].median()

schema_df.loc["WelcomeChange","QuestionText"]

df["WelcomeChange"]

import matplotlib.pyplot as plt
df["WelcomeChange"].value_counts().plot.bar()

df

high_salary=(df["Country"]=="Nepal") & (df["ConvertedComp"] > 10000)
df.loc[high_salary]

# divide data split according to grp and criteria
# split

# apply
# aggregation function mean median mode
# daata transform  acending decending
# data filter
# data combine

df["SocialMedia"].value_counts()

country_group= df.groupby(["Country"])

country_group["SocialMedia"].value_counts().head(50)

country_group["SocialMedia"].value_counts().loc["Nepal"].head(3)

country_group["SocialMedia"].value_counts().loc["Nepal"]

import matplotlib.pyplot as plt
country_group["EdLevel"].value_counts().loc["Nepal"].plot.bar()

country_group["EdLevel"].value_counts().loc["India"].plot.bar()



country_group["Age"].agg(["median","mean","min","max"])

# reset.index()

df

more_analyis= df.groupby(["Country"])

df["Hobbyist"].value_counts()

more_analyis["Hobbyist"].value_counts(normalize=True).loc["Nepal"]

more_analyis["Hobbyist"].value_counts().unstack()

# unstack
# stack

# Some more analysis
# How many developers code as a hobby, and how does it vary across different countries? Hint: Hobbyist and Country
# What is the average number of years developers have been coding professionally? Hint: YearsCodePro
# How does job satisfaction vary based on the number of working hours per week? Hint: JobSat and WorkWeekHrs
# What are the most common web frameworks used by developers, and are there any preferences for the next year? Hint: WebFrameWorkedWith and WebFrameDesireNextYear
# Is there any relationship between compensation and the number of years of coding experience? Hint: ConvertedComp
# Do developers who work remotely report higher career satisfaction compared to those who don't? Hint: WorkRemote and JobSat
# What is the average age of developers across different countries, and how does it affect their career satisfaction? Hint: CareerSat

# df["YearsCodePro"].mean()
# update replace
# astype(float)
# reset_index(name="")

df["YearsCodePro"]=df["YearsCodePro"].replace("Less than 1 year","0")
df["YearsCodePro"]=df["YearsCodePro"].replace("More than 50 years","51").astype(float)
avg=df["YearsCodePro"].mean()
avg

common=df.groupby(["WebFrameWorkedWith"])
common["WebFrameDesireNextYear"].value_counts().unstack()

# expand=True
# unstack groupby
# stack making new column

web_frame=df["WebFrameWorkedWith"].str.split(";",expand=True).stack().value_counts()
web_frame

a=df.groupby(["Gender"])["EdLevel"].value_counts().unstack()
a

df.info()

# Some more analysis
# How many developers code as a hobby, and how does it vary across different countries? Hint: Hobbyist and Country
# What is the average number of years developers have been coding professionally? Hint: YearsCodePro
# How does job satisfaction vary based on the number of working hours per week? Hint: JobSat and WorkWeekHrs
# What are the most common web frameworks used by developers, and are there any preferences for the next year? Hint: WebFrameWorkedWith and WebFrameDesireNextYear
# Is there any relationship between compensation and the number of years of coding experience? Hint: ConvertedComp
# Do developers who work remotely report higher career satisfaction compared to those who don't? Hint: WorkRemote and JobSat
# What is the average age of developers across different countries, and how does it affect their career satisfaction? Hint: CareerSat

ss=df.groupby(["WorkWeekHrs"])["JobSat"].value_counts().unstack()
ss

p=df.groupby(["YearsCodePro"])["ConvertedComp"].mean()
p

df.groupby(["WorkRemote"])["JobSat"].value_counts().unstack().loc["All or almost all the time (I'm full-time remote)"]

df["CareerSat"].value_counts()

#  What is the average age of developers across different countries, and how does it affect their career satisfaction? Hint: CareerSat
d=df.groupby(["CareerSat",'Country'])["Age"].mean()
d

# lambda function
# small function small argument
# 1 expression but many argument
square= lambda x: x**2
square(2)

students = [("Alice", 25), ("Bob", 20), ("Charlie", 30)]
sort=sorted(students, key=lambda x: x[1])
print(sort)



# iii=lambda x : more_analyis["LanguageWorkedWith"].str.split(";",expand=True).stack().value_counts().loc[f"x"]
# iii("Nepal")

# a=more_analyis["LanguageWorkedWith"].str.split(";",expand=True).stack().value_counts()
# a

# problem

more_analysis=df.groupby(["Country"])
c=more_analysis["LanguageWorkedWith"].apply(lambda x : x.str.contains("Python").sum())
c

country_total=df["Country"].value_counts()
country_total

# concate vetically horizontally
# merge index or commn column
python_df = pd.concat([country_total,c],axis="columns")
python_df

python_d = pd.concat([country_total,c],axis="rows")
python_d

